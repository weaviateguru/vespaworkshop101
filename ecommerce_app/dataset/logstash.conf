input {
    file {
        # Path to CSV file - using /data prefix for Docker (dataset directory is mounted to /data)
        path => "/data/myntra_products_catalog.csv"
        # don't store the state of the file, so that Logstash will read the file from the beginning on each restart
        sincedb_path => "/dev/null"
        start_position => "beginning"

        # some rows are split into multiple lines
        codec => multiline {
            # lines start with the ID like this: 10019509,
            pattern => "^\d+,"
            # so if we don't match the pattern
            negate => true
            # this line belongs to the previous row
            what => "previous"
        }
    }
}

filter {
    # parse the CSV file
    csv {
        columns => ["ProductID", "ProductName", "ProductBrand", "Gender", "Price", "NumImages", "Description", "PrimaryColor"]
        # skip the first line, which contains the column names
        skip_header => true
        separator => ","
        quote_char => '"'
    }

    # strip leading and trailing whitespace from fields
    mutate {
        strip => ["ProductName", "ProductBrand", "Gender", "Price", "NumImages", "Description", "PrimaryColor"]
    }

    if "_csvparsefailure" in [tags] {
        # we failed to parse this line, mark it so we don't feed it to Vespa
        mutate {
            add_field => { "skip_line" => true }
        }
    }

    # remove unnecessary fields (this includes tags=[multiline] which is added by the multiline codec if the row is indeed multiline)
    mutate {
        remove_field => ["message", "@timestamp", "@version", "event", "log", "host", "tags"]
    }
}

output {
    # did we fail to parse the line? let's print it
    if [skip_line] {
        stdout { codec => rubydebug }
    } else {
        # otherwise, feed the parsed data to Vespa
        vespa_feed {
            # For local Vespa: use "http://localhost:8080" (no certificates needed)
            # For Vespa Cloud: use your deployment endpoint with mTLS certificates
            # use: `vespa status` to get that vespa_url.
            # Format: https://<endpoint>.<deployment>.<app>.<tenant>.search.vespa.cloud
            vespa_url => "https://cd958fcd.c66e5c39.z.vespa-app.cloud"
            # vespa_url => "http://localhost:8080"
            
            # For Vespa Cloud: mTLS certificate paths (mounted in Docker)
            # Get certificates by running: vespa auth cert
            # They are typically in: ~/.vespa/<tenant>/<app>/<instance>/data-plane-public-cert.pem
            # and: ~/.vespa/<tenant>/<app>/<instance>/data-plane-private-key.pem
            client_cert => "/certs/data-plane-public-cert.pem"
            client_key => "/certs/data-plane-private-key.pem"
            
            namespace => "product"
            document_type => "product"
            # use this field from the parsed CSV as the document ID
            id_field => "ProductID"
        }
    }
}